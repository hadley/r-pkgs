---
title: Git and GitHub
layout: default
output: bookdown::html_chapter
---

# Git and GitHub {#git}

If you're serious about software development, it's really important to learn something about Git. Git is a type of _version control system_, a tool for to tracking changes to your code and sharing those changes with others. Git is most useful when combined with [GitHub](http://github.com), a website that allows you to share your code with the world, solicit code improvements (pull requests) and track issues.

Why use Git and GitHub?

  * Do you have a directory full of files like `my-script.R`, `my-script-1.R`,
    `myscript-2-I-really-hope-this-works.R`, `myscript-FINALLY.R` and so on?
    Git takes care of managing multiple versions of your code so that you
    can easily see what's changed and undo mistakes.

  * It makes it easy for other people to use your package. Any R user can 
    get your package with two lines of code:
    
    ```{r, eval = FALSE}
    install.packages("devtools")
    devtools::install_github("username/packagename")
    ```
    
  * GitHub makes a great minimal website for your package. Readers can easily 
    browse code and read markdown files. They can report bugs or 
    suggest new features with [GitHub issues][gh-issues], and they can propose 
    improvements to your code with pull requests.
    
  * Have your ever collaboratively written code by emailing files back or 
    forth or by sharing a folder in dropbox? It requires a lot of communication 
    to make sure that you're not both working on the same file, accidentally 
    overwriting each others changes. With Git, you can work on the same file at 
    the same time, and Git will either combine your changes automatically, or
    clearly show you the conflicts if there's an ambiguity.

You can do many of the same things with other tools (like [subversion](https://subversion.apache.org) or [mercurial](http://mercurial.selenic.com)) and other websites (like [gitlab](https://about.gitlab.com) and [bitbucket](https://bitbucket.org)). But I think Git and GitHub is the friendliest system for new developers, not least because it's very popular, which means every possible problem has already been asked and answered on StackOverflow. Git and GitHub is the most popular version control system used for R packages, and there are thousands of R packages hosted on GitHub. This chapter describes Git and GitHub together, making no attempt to separate the features of each.

There is a lot to learn about Git, and if you look at tutorials online you'll find that a lot of them give you tremendous amounts of information that you have no idea what to do with or why you should care about it. Don't give up! Using Git will be frustrating at first, but it's worth it to persevere because you'll unlock the super-power of code collaboration.

## RStudio, Git and GitHub

RStudio makes your day-to-day use of Git as easy as possible. Once you've set up a project to use Git, you'll get a new toolbar icon and a new pane. They provide shortcuts for the most commonly used Git commands. However, there are over 150 Git commands, and only a handful are available in Rstudio. That means you'll need to run some commands from a shell (aka a console), especially when you're setting up, dealing with merge conflicts and getting out of jams. It's also important to be familiar with using Git from the command line because if you get stuck, you'll need to search for a solution using the standard command names.

The easiest way to get to a shell from RStudio is Tools > Shell. It will open a new shell located in the root directory of your project. (NB: on windows, this opens up a _bash_ shell, the standard linux shell, which behaves a little differently to the usual `cmd.exe`.) 

If you've never used the shell before, don't worry, it's very similar to using R. The main difference is that instead of functions, you call commands. Commands have a slightly different syntax (unfortunately shell commands are even less regular than R functions, but you'll only need a couple). For example, in R you might write `f(x, y = 1)`, where in the shell you'd write `f x --y=1` or `f x -y1`. In this chapter, you won't be doing much in the shell apart from running the Git commands that I give you. However, it's a good idea to learn the three most important shell commands:

* `pwd`: print working directory. This tells you where you are now.
* `cd <name>`: change directory. Use `cd ..` to go up the directory hierarchy.
* `ls`: list files. Shows all files in the current directory.

If you've never used the shell before, I recommend playing [Terminus](http://web.mit.edu/mprat/Public/web/Terminus/Web/main.html). It's a fun way to learn the basics of the shell. I also recommend try Philip Guo's [Basic Unix-like command line tutorial](http://pgbovine.net/command-line-tutorial.htm) videos, <http://www.ee.surrey.ac.uk/Teaching/Unix/unix1.html>, and <https://p1k3.com/userland-book/>.

## Initial set up {#git-init}

If you've never used Git or GitHub before, start by installing Git, creating a GitHub account and connecting the two together:

1.  Install Git:

    * Windows: <http://git-scm.com/download/win>.
    * OS X: <http://git-scm.com/download/mac>.
    * Debian/Ubuntu: `sudo apt-get install git-core`.
    * Other linux distros: <http://git-scm.com/download/linux>.

1.  Tell Git your name and email address. These are used to label each commit
    so that when you start collaborating with others, it's clear who made 
    each change. In a shell, run:

    ```bash
    git config --global user.name "<YOUR NAME>"
    git config --global user.email "<YOUR EMAIL ADDRESS>"
    ```

    (You can check if you're set up correctly by running 
    `git config --global --list`.)

1.  Create a free account on GitHub, <https://github.com>. Use the same
    name and email address as above.
    
1.  If needed, generate a SSH key-pair. SSH keys are used to securely communicate
    with websites without needing a password. There are two parts to an SSH key:
    public and private. If someone has your public key, they can securely
    encrypt data in a way that only your private key can open.
    
    You can check if you already have an SSH key-pair by running:
    
    ```{r, eval = FALSE}
    file.exists("~/.ssh/id_rsa.pub")
    ```

    If that returns `FALSE`, you'll need to create a new key. You can follow the 
    [GitHub instructions](https://help.github.com/articles/generating-ssh-keys) 
    or use RStudio. Go to RStudio preferences, choose the Git/SVN panel, then 
    click "Create RSA key...":
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-config-2.png", dpi = 220)
    ```
    
1.  Tell GitHub what your SSH public key is at <https://github.com/settings/ssh>. 
    The easiest way to find the key is to click "View public key" in the
    Git/SVN preferences pane.

## Create a local Git repository {#git-init}

Now that you have Git installed and configured, you can use it! For each package that you want to use GitHub with, you'll need to initialise a local repository, or __repo__ for short. This creates a `.git` directory which stores configuration files and a database that records changes to your code. A new repo exists only on your computer; you'll learn how to share it with others shortly.

To create a new repo:

  * In RStudio, go to project options, then the Git/SVN panel. Change the 
    "Version control system" from "None" to "Git":
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-proj-config.png", dpi = 220)
    ```
    
    You'll then be prompted to restart RStudio.

  * In a shell, run `git init`. Restart RStudio and reopen your package.

Once Git has been initialised, you'll see two new components in the IDE:

  * The __git pane__, found at the top-right, shows you what files have 
    changed and exposes the most important Git commands as buttons:
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-pane.png", dpi = 220)
    ```
    
  * The __git dropdown__, found in the toolbar, exposes Git and GitHub commands
    that apply to the current file:
  
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-dropdown.png", dpi = 220)
    ```

## See what's changed {#git-status}

The first benefit to using Git is that you can easily see what you've changed. I find this really helpful, as I often accidentally mistype keyboard shortcuts, leaving stray characters in my code. The RStudio Git pane lists every file that's been added, modified or deleted. The icon describes the change:

* `r bookdown::embed_png("screenshots/git-modified.png", dpi = 220)`, 
  __Modified__. You've changed the contents of the file.

* `r bookdown::embed_png("screenshots/git-unknown.png", dpi = 220)`, 
  __Untracked__. You've added a new file that Git hasn't seen before.

* `r bookdown::embed_png("screenshots/git-deleted.png", dpi = 220)`, 
  __Deleted__. You've deleted a file.

You can get more details about modifications with a "diff", `r bookdown::embed_png("screenshots/git-diff.png", dpi = 220)`. This opens a new window showing the detailed **diff**erences:

```{r, echo = FALSE}
bookdown::embed_png("screenshots/git-diff-window.png", dpi = 220)
```

The background colour tells you whether the text has been added (green) or removed (red). (If you're colour blind you can use the line numbers in the two columns on the far left. A number in the first column means old version, a number on right new version.) Context, lines surrounding the change, are shown in grey, and help you to place the change in the context of complete file. 

In the shell, use `git status` to show an overview of changes and `git diff` to see detailed differences. 

## Record changes {#git-commit}

The fundamental unit of work in Git is a __commit__. A commit takes snapshot of your code at a specified point in time. If you make a mistake, you can rollback changes to a previous commit. Using a Git commit is like using an anchor when climbing. If you're crossing a dangerous rock face you want to make sure you've used protection to catch you if you fall. Commits play a similar role: if you make a mistake, you can't fall past the previous commit. Coding without commits is like free-climbing: you can travel much faster in the short-term, but in the long-term the chances of catatrosphic failure are high! Like rock climbing protection, you want to be judicious in your use of commits. Committing too frequently will slow your progress; use more commits when you're in uncertain or dangerous territory. Commits are also helpful to others, because they show your journey, not just the destination.

There are five key components to every commit:

* A unique identifier, called a SHA (short for secure hash algorithm).

* A changeset that describes which files were added, modified and deleted.

* A human-readable commit message.

* A parent, the commit that came before this one. (There are two exceptions to 
  this rule: the initial commit doesn't have a parent, and merges, which you'll
  learn about later, have two parents.)

* An author.

You create a commit in two stages:

1.  You __stage__ files, telling Git which changes should be included in the
    next commit. 
  
1.  You __commit__ the staged files, describing the changes with a message.

In RStudio, staging and commmiting are done in the commmit window, which you can open by clicking `r bookdown::embed_png("screenshots/git-commit.png", dpi = 220)` or by pressing Ctrl + Alt + m.

```{r, echo = FALSE}
bookdown::embed_png("screenshots/git-commit-window.png", dpi = 220)
```

The commit window is made up of three panes:

* The top-left pane shows the current status, the same as the Git pane in the 
  main RStudio window.

* The bottom pane shows the diff of the currently selected file.

* The top-right pane is where you'll enter the commit message, a human 
  readable message summarising the changes made in the commit. More on 
  that shortly.

(Yes, this is exactly the same window you see when clicking `r bookdown::embed_png("screenshots/git-diff.png", dpi = 220)`!)

To create a new commit:

1.  __Save your changes__.

1.  __Open the commit window__ by clicking 
    `r bookdown::embed_png("screenshots/git-commit.png", dpi = 220)` or 
    pressing `Ctrl + Alt + m`.  

1.  __Select files__.  To stage (select) a single file for inclusion, tick its
    check box. To stage all files, press Cmd + A, then click 
    `r bookdown::embed_png("screenshots/git-stage.png", dpi = 220)`. 
    
    As you stage each file, you'll notice that its status changes. The icon
    will change columns from right (unstaged status) to left (staged status),
    and you might see one of two new new icons:

      * Added: `r bookdown::embed_png("screenshots/git-added.png", dpi = 220)`: 
        after staging an untracked file, Git now knows that you want to add it 
        to the repo.
      
      * Renamed: `r bookdown::embed_png("screenshots/git-renamed.png", dpi = 220)`:
        If you rename a file, Git initially sees it as a deletion and addition.
        Once you stage both changes, Git will recognise that it's a rename.
        
    Sometimes you'll see a status in both columns, e.g. 
    `r bookdown::embed_png("screenshots/git-modified-staged.png", dpi = 220)`.
    This means that you have both staged and unstaged changes in the same file.
    This happens when you've made some changes, staged them, and then made some 
    more. Clicking the staged checkbox will stage your new changes, clicking
    it again will unstage both sets of changes.

1.  __Stage files__, as above.

1.  __Write a commit message__ (top-right panel)  which describes the changes
    that you've made. The first line of a commit message is called the subject 
    line and should be brief (50 characters or less). For complicated commits, 
    you can follow it with a blank line and then a paragraph or bulleted list 
    providing more detail. Write messages in imperative, like you're telling 
    someone what to do: "fix this bug", not "fixed this bug" or 
    "this bug was fixed".
    
1.  __Click Commit__.

Staging files is a little more complicated in the shell. You use `git add` to stage new and modified files, and `git rm` to stage deleted files. To create the commit, use `git commit -m <message>`.

## Commit best practices {#commit-best-practices}

Ideally, each commit should be:

* __Related__: All the changes in the commit should be related to the same
  goal. This makes it easier to understand the commit at a glance, and to 
  describe it with a simple message.

* __Minimal__: A commit should contain nothing but the related changes. If 
  while making one set of changes you discovered another problem,
  do a separate commit.

* __Complete__: A commit should solve the problem that it claims to solve.
  If you think you've fixed a bug, the commit should contain a unit test
  that confirms that you're right.

Each commit message should:

* __Be concise, yet evocative__. You want to be able to take in at a glance
  what a commit does, but there should be enough detail so you can remember
  (or understand) what happened.

* __Describe the why, not the what__. You can always retrieve the diff 
  associated with a commit, so the message doesn't need to say exactly what 
  changed. Instead it should provide a high-level summary, and focus on the 
  motivation for the change.

If you do this then:

* It's easier to work with others. If two people have changed the same file
  in the same place, it's easier to resolve the conflict if the commits are
  small and it's clear why each change was made.
  
* Project newcomers can easily understand history by reading the commit logs.
  
* You can load and run your package at any point in its life. This can
  be tremendously useful in conjunction with tools like 
  [bisectr](https://github.com/wch/bisectr), which allow you to use binary
  search to quickly find the commit that introduced a bug.

* When you discover exactly when you introduced a bug, you can easily 
  understand what you were doing (and why!).

The time you spend on your commits is inversely proportional to the amount of time others will spend understanding the history of your project. You might think that no one else will ever look at your repo, but every project has one very important collaborator: future-you! If you spend a little time now to polishing your commit messages, future-you will thank you when they do a post-mortem on a bug. 

Remember that these directives are aspirational, and you shouldn't let them get in your way. If you look at the commit history of my repositories, you'll notice a lot of them aren't that good, especially when I start to get frustrated that I __still__ haven't managed to fix a bug. Strive to follow these guidelines, but remember it's better to have multiple bad commits than one perfect commit.

## Ignoring files

There are often files that you don't want to include in the repository. They might be transient artefacts (like LaTex or C build artefacts), very large, or generated on demand. Instead of carefully not-staging them each time, you should add them to `.gitignore` to prevent them from ever being added. The easiest way to do this is to right-click on the file in the Git pane  and select `Ignore`:

```{r, echo = FALSE}
bookdown::embed_png("screenshots/git-ignore.png", dpi = 220)
```

If you want to ignore multiple files, you can use a wildcard "glob" like `*.png`. To learn more about the options, see [ignoring files](http://git-scm.com/book/ch2-2.html#Ignoring-Files) in Pro-Git.

Some developers never commit derived files, files that can be generated automatically. For an R package this would mean never checking in the `NAMESPACE` or `man/` directory because they're generated from comments. Pragmatically, it's better to commit these files because R packages have no way to generate `.Rd` files on install, so if you don't check them in users who install your package from GitHub will have no documentation.

## Undo a mistake {#git-undo}

The best thing about using commits is that you can undo mistakes. RStudio makes it easy to undo recent mistakes:

*   To undo the changes you've just made to a file, right click on it in the Git 
    pane and select "revert". This will roll any changes back to the last commit. 
    Beware: you can't undo this operation!
  
    You can undo changes to just part of a file in the diff window. Look for a
    __discard chunk__ button above the block of changes that you want to undo:
    `r bookdown::embed_png("screenshots/git-chunk.png", dpi = 220)`. You can
    also discard changes to individual lines or the selected text.
  
*   If you committed changes too early, you can modify the last commit by 
    staging the extra changes. Before you click commit, select 
    `r bookdown::embed_png("screenshots/git-commit-amend.png", dpi = 220)`. 
    (But don't do this if you've pushed the previous commit to GitHub - you're
    effectively rewriting history, which should be done with care when you're 
    doing it in public.)
  
If you didn't catch the mistake right away, you'll need to look backwards in history and find out where it occured:

1.  Open the history window by clicking
    `r bookdown::embed_png("screenshots/git-history.png", dpi = 220)` in the 
    Git pane.
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-history-window.png", dpi = 220)
    ```

    The history window is divided into two parts. The top part lists every
    commit part to your repo. The bottom part shows you the commit:
    the SHA (the unique id), the author, the date, the parent and 
    the changes in the commit.
     
1.  Navigate back in time until you find the commit where the mistake occured.
    Write down the parent SHA: that's the commit that occured before the mistake
    so it will be good.
    
Now you can use that SHA in the shell:

*   See what the file looked in the paste so you can copy-and paste the old
    code:
    
    ```bash
    git show <SHA> <filename>
    ```

*   Or copy the version from the past back in to the present:

    ```bash
    git checkout <SHA> <filename>
    ```
    
In both cases you'll need to finish by staging and commiting the files.

(It's also possible to use Git as if you went back in time and prevented the mistake from happening in the first place. This is called __rebasing history__ and is an advanced technique. As you can imagine, going back in time to change the past can have profound impacts on the present. It can be useful, but needs extreme care.)

If you're still stuck, try <http://sethrobertson.github.io/GitFixUm/fixup.html> or <http://justinhileman.info/article/git-pretty/>. They give step-by-step approaches to fixing many common (and not so common!) problems.

## Synchronising with GitHub {#github-init}

So far we've only been working locally, using commits to track the progress of a project and provide safe checkpoints. However, Git really shines when you start publishing your code in the open. We're going to use [GitHub](http://github.com) to do this. There are other choices, but GitHub is free for open source projects, has all the features you'll need and is popular choice in the R world. 

To publish, or __push__, your code to GitHub:

1.  Create a new repo on GitHub: <https://github.com/new>. Give it the same
    name as your package, and include the package title as the repo
    description. Leave all the other options as is, then click Submit.

1.  Open a shell, then follow the instructions on the new repo page. 
    They'll look something like this:

    ```bash
    git remote add origin git@github.com:hadley/r-pkgs.git
    git push -u origin master
    ```
    
    The first line tells Git that your local repo should have a remote version 
    that lives on GitHub, and calls it "origin". The second line pushes all 
    of your current work to that repo.

Now let's make a commit and verify that the remote repo updates:

1.  Modify `DESCRIPTION` to add `URL` and `BugReports` fields to your that link 
    to your new GitHub site. For example, dplyr has:

    ```yaml
    URL: http://github.com/hadley/dplyr
    BugReports: http://github.com/hadley/dplyr/issues
    ```

1.  Save the file and commit (with message "Updating DESCRIPTION to add links
    to GitHub site").
    
1.  __Push__ your changes to GitHub by clicking 
    `r bookdown::embed_png("screenshots/git-push.png", dpi = 220)`. (This is 
    the same as running `git push` in the shell). 
    
1.  Go to your GitHub page and look at the `DESCRIPTION`.

Usually, each push will include multiple commits, because you push much less often than you commit. How often you push versus committing is completely up to you, but pushing code is publishing code, and so you should strive to publish clean code that works.  Once you've learned about `R CMD check` in [automated checking](#check), I recommend always running it before you push. If you want to publish code that doesn't work (yet), I recommend using a branch, as you'll learn about in [branching](#git-branch).

Once you've connected your repo to GitHub, the Git pane will show you how many commits you have locally that are not on GitHub: `r bookdown::embed_png("screenshots/git-local-commits.png", dpi = 220)`. This message indicates that I have 1 commit locally (my branch) that is not on GitHub ("origin/master").

## Benefits of using GitHub {#github-benefit}

1.  You get a decent website. The GitHub page for your project, e.g. 
    <https://github.com/hadley/testthat> (the GitHub repo for testthat), lists 
    all the files and directories in your package. `.R` files are nicely syntax 
    highlighted, and `.md`/`.Rmd` files are rendered as html. If you have a 
    `README.md` file in the top-level directory, it will also be displayed on 
    the homepage. You'll learn more about the benefits of creating this file in 
    [README.md](#readme). 

1.  It's easy to install your package:

    ```r
    devtools::install_github("<your_username>/<your_package>")
    ``` 
    
    This makes it really easy for others to benefit from your hard work.

1.  You can track the history of the project in the commit view, e.g. 
    <https://github.com/hadley/testthat/commits/master>. When I'm working on a 
    a collaborative package, I often keep this page open so I can see what 
    they're working on.  Individual commits show the same information that you 
    see in the commit/diff window in RStudio.

1.  It's easy to see the history of a file. Navigate to the file, then click
    __History__. This shows every commit that affected this current file. 
    Another useful view is __Blame__; it shows you the last commit to
    each line of code, it shows you the last commit to touch that line. This is 
    tremendously helpful when you've discovered a bug and want to understand
    its history.
    
    You can jump directly to these pages from RStudio with the Git dropdown in
    the main toolbar: 
    
    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/git-dropdown.png", dpi = 220)
    ```

1.  You can comment on commits. Either use the comment box at the bottom of 
    the page to comment on the commit as a whole, or comment on individual lines 
    by clicking the plus sign next to the line number,
    `r bookdown::embed_png("screenshots/github-comment-line.png", dpi = 220)`. 
    This is a great way to let your collaborators know if you see a mistake or 
    have a question. It's better than email because it's public so anyone 
    working on the repo (both present and future) can see the conversation.

## Working with others {#git-pull}

You use __push__ to send your changes to GitHub. If you're working with other people, they're also pushing their changes to GitHub, so you'll need to __pull__ their changes from GitHub to see them locally. To make sure everyone stays in sync, Git only lets you push to a repo if you've retrieve the most recent version with pull.

When you pull, Git first downloads (__fetches__) all of the changes then __merges__ them into the changes that you've made. A merge is a commit with two parents. It takes two different lines of development and combines them into a single result. To do so, Git needs to combine two sets of changes. In many cases it can do so automatically: for example, if the changes are to different files, or even different parts of the same file. However, if the changes are to the same place in a file, you'll need to resolve the changes yourself. This is called a __merge conflict__.

In RStudio, you'll discover that you have merge conflict when:

* Pull fails with an error.

* In the Git pane, you see a status like
  `r bookdown::embed_png("screenshots/git-commit-conflict.png", dpi = 220)`

RStudio currently doesn't provide any tools to help with merge conflicts, so you'll need to use the command line. I recommend starting by setting your merge conflict "style" to `diff3`. The `diff3` style shows three things when you get a merge conflict: your local changes, the original file and remote changes. The default style is `diff2`, which only shows your changes and the remote changes, which generally makes it harder to figure out what's happened. 

* If you've encountered your first merge conflict:

    ```bash
    # Abort this merge
    git merge --abort
    # Set the conflict style
    git config --global merge.conflictstyle diff3
    # Re-try the merge
    git pull
    ```
    
* If you're not in the middle of a merge conflict, just run 

    ```bash
    git config --global merge.conflictstyle diff3
    ```

To resolve the merge conflict, you need to open every file with the status `r bookdown::embed_png("screenshots/git-commit-conflict.png", dpi = 220)`. In each file, you'll find a conflict marker that looks like this:

```
<<<<<<< HEAD

||||||| merged common ancestors

=======

>>>>>>> remote
```

This shows all three versions of the conflicting code:

* At top, your local code.

* In the middle, the code from the last commit that was in common between the
  two lines of development. (This is missing in the default conflict style, so 
  if you don't see it, follow the instructions above).

* At bottom, the remote code that you pulled down.

You need to work through each conflict and decide either which version is better, or how to combine the changes from both versions. Make sure you delete the conflict markers to resolve the conflict, then stage the file. Once you've fixed all conficts, make a new commit and push to GitHub.

A couple of pointers when fixing text generated by roxygen:

* Don't fix problems in `man/*.Rd` files. Instead, resolve the conflicts in 
  the underlying roxygen comments and re-document the package.
   
* Merge conflicts in the `NAMESPACE` file will prevent you from re-loading or 
  re-documenting the package. Resolve them enough so that the package 
  can be loaded, then re-document to generate a clean and correct `NAMESPACE`.

Handling merge conflicts is one of the trickier parts of Git, and you may need to read a few tutorials before you get the hang of it. Google and StackOverflow are great resources. If you get terribly confused, you can always abort the merge and try again by running `git merge --abort` then `git pull`.

## Issues {#github-issues}

Every GitHub repo comes with a page for tracking issues. Use them! If you encounter a bug while working on another project, jot a note down in your issues. When you have a smaller project, don't worry too much about milestones, tags and assigning issues to specific people. Those are more useful once you get over a page of issues (>50). Once you get to that point, read the GitHub guide on issues: <https://guides.github.com/features/issues/>.

A useful technique is closing issues from a commit message. Just put `Closes #<issue number>` somewhere in your commit message and GitHub will close the issue for you when you next push. The best thing about closing issues this way is that it makes a link from the issue to the commit. This is useful if you ever have to come back to the bug and want see exactly what you did to fix it. You can also link to issues without closing them; just refer to `#<issue number>`.

As you'll learn about in [NEWS.md](#news), it's a good idea to add a bullet to `NEWS.md` 
whenever you close an issue. The bullet point should describe the issue in terms that users will understand, as opposed to the commit message, which is written for developers.

## Branches {#git-branch}

Sometimes you need to make a big change to your code. You want to break it up into multiple simple commits so you can easily track what you're doing, but you don't want to merge them into the mainstream of development. Or maybe you're not sure what you've done is the best approach and you want someone else to review your code. Or maybe you want to try something experimental; you only want to merge it back in if the experiment succeeds.  Branches and pull requests provide powerful tools to handle these situations.

Although you haven't realised it, you're already using branches. The default branch is called __master__, and it's where you've been saving your commits. If you synchronise your code to GitHub, you have another branch called __origin/master__, which is a local copy of all the commits on GitHub, synchronised when you pull. `git pull` does two things:

1.  `git fetch origin master` updates the local `origin/master` branch with
    the latest commits from GitHub.
  
1.  `git merge orgin/master` combines the remote changes with your changes.

It's useful to create your own new branches when you want to break off the mainstream of development for a while. Create a new branch with `git checkout -b <branch-name>`. Names should use lower case letters, numbers, and `-` to separate words. 
  
Switch between branches with `git checkout <branch-name>`. For example, return to the mainline of development with `git branch master`. You can also use the branch switcher at the top right of the Git pane:
  
```{r, echo = FALSE}
bookdown::embed_png("screenshots/git-branch.png", dpi = 220)
```

If you've forgotten the name of your branch in the shell, you can use `git branch` to list all existing branches. 

If you try to synchronise this branch to GitHub from inside RStudio, you'll notice that push and pull are disabled: `r bookdown::embed_png("screenshots/git-no-remote.png", dpi = 220)`. To enable them, you'll need to first tell Git that your local branch should have a remote equivalent:

```bash
git push --set-upstream origin <branch-name>
```

After you've done that the first time you can use the pull and push buttons like usual.

If you've been working in a branch for a while, other work might have been going on in master. To integrate that work into your branch, run `git merge master`. You will need to resolve any merge conflicts as described above. It's best to do this fairly frequently - the less your branch has diverged from the master, the easier it will be to merge.

Once you're done working in a branch, merge it back into master, then delete it:

```bash
git checkout master
git merge <branch-name>
git branch -d <branch-name>
```

(Git won't let you delete a branch unless you've merged it back into master. If you do want to abandon a branch without merging it, you'll need to force delete with `-D` instead of `-d`. If you accidentally delete a branch that you didn't mean to, don't panic; it's usually possible to get it back. See the advice in undoing mistakes).

## Making a pull request {#git-pullreq}

A pull request is a tool for proposing and discussing changes before merging them into a repo. The most common use for a pull request is to contribute to someone elses code: it's the easiest way to propose changes to code that you don't control. However, you're going to learn about them first in the context of your own code. They seem a bit pointless here, because you don't _need_ them, as you can directly modify the code. But pull requests are surprisingly useful because they allow you to get feedback on a proposed set of changes. We use them frequently at RStudio to get feedback before merging major changes.

GitHub has some good documentation on using pull requests: <https://help.github.com/articles/using-pull-requests/>. In this chapter, I'll focus on the minimum you need to know to use pull requests effectively, and show you how they tie in to the Git commands you've learned so far.

To create a pull request, you create a branch, commit code, then push the branch to GitHub. When you next go to the GitHub website you'll see a header that invites you to submit a pull request. You can also do it by:

1.  Switching branches: 

    ```{r, echo = FALSE}
    bookdown::embed_png("screenshots/github-branches.png", dpi = 220)
    ```

1.  Clicking `r bookdown::embed_png("screenshots/pr-create.png", dpi = 220)`

This will create a page that looks like this:

```{r, echo = FALSE}
bookdown::embed_png("screenshots/pr.png", dpi = 220)
```

This pull request is one submitted to this book's GitHub site, fixing a couple of small problems.

There are three parts to a pull request:

* A __conversation__, 
  `r bookdown::embed_png("screenshots/pr-conversation.png", dpi = 220)`,
  where you can discuss the changes as a whole.
  
* The __commits__ view, 
  `r bookdown::embed_png("screenshots/pr-commits.png", dpi = 220)`,
  where you can see each individual commit.
  
* The __file changes__,
  `r bookdown::embed_png("screenshots/pr-changes.png", dpi = 220)`,
  where you see the overall diff of the commits, and you can comment
  on individual lines.

Once you've done discussing a pull request, you either choose to merge it or delete it. Merging it is equivalent to running `git merge <branchname>` from the shell; deleting is equivalent to `git branch -r <branchname>`.

## Submitting a pull request to another repo {#pr-make}

To submit a pull request to a repo that you don't own, you first need to create a copy of the repo that you do own, called a __fork__, and clone that repo on your own computer:

1.  __Fork__ the original repo by visiting the repo on GitHub and clicking
    `r bookdown::embed_png("screenshots/github-fork.png", dpi = 220)`. 
    This creates a copy of the repo that belongs to you. 

1.  __Clone__ the forked repo to create a local copy of the remote repo. 
    It's possible to do this from RStudio (using "Create new project" from 
    "Version control") but I think it's easier to do it from the shell:
    
    ```bash
    git clone git@github.com:<your-name>/<repo>.git
    cd <repo>
    ```

A fork is a _static_ copy of the repo: once you've created it, GitHub does nothing to keep it in sync with the upstream repo. This is a problem because while you're working on the pull request, changes might also been going on in the original repo, and you need to keep the forked and the original repo in sync. Start by telling your repo about the upstream repo:

```bash
git remote add upstream git@github.com:<original-name>/extrafont.git
git fetch upstream
```

Then you can merge changes from the upstream repo in your local copy:

```bash
git merge upstream/master
```

When working on a forked repo, I recommend that you don't work on the master branch. You're fundamentally not on the main line of develoment for that repo, so using master makes things confusing. If you always create pull requests in branches, you can make it a little easier to keep your local repo in sync with the upstream repo by running:

```bash
git branch -u upstream/master   
```

Then you only need this code to update your local repo:

```bash
git checkout master
git pull
```

Changes may occur while you're working on the pull request, so remember to merge them into your branch with:

```bash
git checkout <my-branch>
git merge master
```

A pull request is a one-to-one mapping to a branch, so you can also use this technique to make updates based on the pull request discussion. Don't create a new pull request each time you make a change; instead you just need to push the branch that the PR is based on and the PR webpage will automatically update.

The diagram below illustrates the main steps when first creating a pull request and then updating it when the upstream repo changes:

```{r, echo = FALSE}
bookdown::embed_png("diagrams/pull-request-process.png", dpi = 220)    
```

## Reviewing and accepting pull requests {#pr-accept}

As your packages get more popular, you're likely to also recieve pull requests. Recieving a pull request is fantastic. Someone not only cares about your package enough to use it, they've actually read the source code and make an improvement!

When you receive a pull request, I recommend reviewing it using the three step approach described by Sarah Sharp. I summarise the three phases below, but I highly recommend reading the full article at <http://sarah.thesharps.us/2014/09/01/the-gentle-art-of-patch-review/>:

1.  Is it a good idea? If you don't think the contribution is a good fit for 
    your project, it's polite to let the contributer know as quickly as 
    possible. Thank them for their work, and refocus them on a better area to 
    work on.
    
1.  Is the overall approach sound? At this point you want to focus on the big
    picture: have they modified the right functions in the right way? Avoid
    nit-picking minor style problems (that's the final phase), insteed just 
    providing a pointer to your style preferences, e.g. 
    <http://r-pkgs.had.co.nz/style.html>.

1.  Is it polished? In the final review phase, make sure that the non-code
    parts of the PR are polished. Prompt the contributer to update the 
    documentation, point out spelling mistakes and suggest better wording.
    
    I recommend asking the contributor to include a bullet point in `NEWS.md`, 
    briefly describing the improvement and thanking themselves with their GitHub 
    username. More details to follow in  [post release](#post-release)).

After discussion is complete, you can incorporate the changes by clicking the merge button. If the button doesn't work, GitHub provides some instructions to do it from the command line. You've seen all the pieces before, so it's useful to read through just so you understand exactly what's happening.

```bash
# Create a new branch, and sync it with the pull request
git checkout -b <branch> master
git pull https://github.com/<user>/<branch>.git patch-3

# Merge the changes into the main line of development
git checkout master
git merge --no-ff <branch>
# Resolve conflicts, stage and add.

# Sync your local changes with GitHub
git push origin master
```

## Learning more

Git and GitHub are a rich and powerful set of tools, and there's no way this chapter has taught you everything you need to know. However, you should now have the minimum knowledge to be effective, and you're in a good place to learn more. Some good resources are:
  
* GitHub help, <https://help.github.com>, not only teaches you about
  GitHub, but also has good tutorials on many Git features.

* If you'd like to learn more about the details of Git, read 
  [Pro Git](http://git-scm.com/book/en/v2) by Scott Chacon and Ben Straub.

Finally, StackOverflow is a vital part of Git - when you have a problem that you don't know how to solve, SO should be your first resource. It's highly likely that some one has had exactly the same problem as you, and there will be a variety of approaches to choose from.

[gh-issues]:https://guides.github.com/features/issues/
[gh-pr]: https://help.github.com/articles/using-pull-requests/
[gh-releases]: https://help.github.com/articles/about-releases/
