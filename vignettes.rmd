---
title: Documenting packages
layout: default
output: bookdown::html_chapter
---

# Package documentation {#vignette}

A vignettes is a long-form guides to your package. The goal of a vignette is to get you to the point where function documentation is useful. While function documentation helps you if you know the name of the function you need, it is otherwise useless. A vignette is like a book chapter or an academic paper: it should describe the problem that your package is designed to solve, and then show the reader how to solve it. A vignette should divide functions into useful categories, and demonstrate how to coordinate multiple functions to solve problems.

Many existing packages have vignettes. You can see all the installed vignettes with `browseVignettes()`. To see the vignette for a specific package, use the argument, `browseVignettes("packagename")`. Each vignette provides three things: the original source file, a readable HTML page or PDF, and a file of R code. You can read a specific vignette with `vignette(x)`, and see its code with `edit(vignette(x))`. To see vignettes for a package you haven't installed, look at its CRAN page, e.g., <http://cran.r-project.org/web/packages/dplyr>.

Before R 3.0.0, the only way to create a vignette was with Sweave. This was painful because Sweave only worked with LaTeX, and LaTeX is both hard to learn and slow to compile. Now, any package can provide a vignette __engine__, a standard interface for turning input files into HTML or PDF vignettes. In this chapter, we're going to use the R markdown vignette engine provided by [knitr](http://yihui.name/knitr/). I recommend this engine because:

* You write in Markdown, a plain text formatting system. Markdown is limited
  compared to LaTeX, but this limitation is good because it forces you to
  focus on content, rather than appearance.
  
* It can intermingle text, code and results (both textual and visual).

* Your life further simplified by the [rmarkdown package](http://rmarkdown.rstudio.com/), 
  which coordinates Markdown and knitr by using [pandoc](http://johnmacfarlane.net/pandoc) 
  to convert Markdown to HTML and by providing many useful templates.

Switching from Sweave to R Markdown had a profound impact on my use of vignettes. Previously, making a vignette was painful and slow and I rarely did it. Now, vignettes are an essential part of my packages. I use them whenever I need to explain a complex topic, or to show how to solve a problem with multiple steps.

Currently, the easiest way to get R Markdown is to use [RStudio](http://www.rstudio.com/products/rstudio/download/preview/). RStudio will automatically install all of the needed prerequisites. If you don't use RStudio, you'll need to:

1. Install the rmarkdown package with `install.packages("rmarkdown")`.

1. [Install pandoc](http://johnmacfarlane.net/pandoc/installing.html).  

## Vignette workflow {#vignette-workflow}

To create your first vignette, run:

```{r, eval = FALSE}
devtools::use_vignette("my-vignette")
```

This will:

1.  Create a `vignettes/` directory.

1.  Add the necessary dependencies to `DESCRIPTION` (i.e. it adds knitr to 
    the `Suggests` and `VignetteBuilder` fields).

1.  Draft a vignette, `vignettes/my-vignette.Rmd`.

The draft vignette has been designed to remind you of the important parts of an R Markdown file. It serves as a useful reference when you're creating a new vignette.

Once you have this file, the workflow is straightforward:

1.  Modify the vignette.

2.  Press Cmd + Shift + K (or click 
    `r bookdown::embed_png("screenshots/knit.png", dpi = 220)`) to knit the 
    vignette and preview the output.

There are three important components to an R Markdown vignette:

* The initial metadata block.
* Markdown for formatting text.
* Knitr for intermingling text, code and results.

These are described in the following sections.

## Metadata {#vignette-metadata}

The first few lines of the vignette contain important metadata. The default template contains the following information:

    ---
    title: "Vignette Title"
    author: "Vignette Author"
    date: "`r Sys.Date()`"
    output: rmarkdown::html_vignette
    vignette: >
      %\VignetteIndexEntry{Vignette Title}
      %\VignetteEngine{knitr::rmarkdown}
      %\usepackage[utf8]{inputenc}
    ---

This metadata is written in [yaml](http://www.yaml.org/), a format designed to be both human and computer readable. The basics of the syntax is much like the DESCRIPTION, each line consists of a field name, a colon, then the value of the field. The one special YAML feature we're using here is `>`: that indicates the the following lines of text are plain text and shouldn't use any special YAML features.

The fields are:

* Title, author and date: this is where you put the vignette's title, author and 
  date. You'll want to fill these in yourself (you can delete them 
  if you don't want the title block at the top of the page). The date is filled 
  in by default: it uses a special knitr syntax (explained below) to insert 
  today's date. 
  
* Output: this tells rmarkdown which output format specification to use. 
  There are many options that are useful for regular reports (including
  html, pdf, slideshows, ...) but `rmarkdown::html_vignette` has been 
  specifically designed to work well inside packages. See 
  `?rmarkdown::html_vignette` for more details.
  
* Vignette: this contains a special block of metadata needed by R. Here, you can 
  see the legacy of the fact that vignettes were originally written in LaTeX: the 
  metadata actually look like LaTeX commands. You'll need to modifiy the 
  `\VignetteIndexEntry` to provide the title of your vignette as you'd like it to 
  appear in the vignette index. Leave the other two lines as is. They tell R to 
  use `knitr` to process the file, and that the file is encoded in UTF-8 (the only 
  encoding you should ever use to write vingettes).

## Markdown {#markdown}

R Markdown vignettes are written in Markdown. John Gruber, the author of Markdown, summarises the goals and philosophy of markdown:

> Markdown is intended to be as easy-to-read and easy-to-write as is feasible.
>
> Readability, however, is emphasized above all else. A Markdown-formatted 
> document should be publishable as-is, as plain text, without looking like 
> it’s been marked up with tags or formatting instructions. While Markdown’s 
> syntax has been influenced by several existing text-to-HTML filters — 
> including Setext, atx, Textile, reStructuredText, Grutatext, and EtText — 
> the single biggest source of inspiration for Markdown’s syntax is the format 
> of plain text email.
>
> To this end, Markdown’s syntax is comprised entirely of punctuation 
> characters, which punctuation characters have been carefully chosen so as 
> to look like what they mean. E.g., asterisks around a word actually look 
> like *emphasis*. Markdown lists look like, well, lists. Even blockquotes 
> look like quoted passages of text, assuming you’ve ever used email.

Markdown isn't as powerful as LaTeX or reStructuredText or docbook, but it is simple, easy to write, and easy to read even when not rendered. I find the constraints of markdown actively helpful for writing because it lets me focus on the content, and prevents me from messing around with the styling.

If you've never used markdown before, a good place to start is the [Markdown syntax documentation](http://daringfireball.net/projects/markdown/syntax), written by John Gruber, the author of the original markdown. Pandoc's implementation of markdown cleans up a number of rough edges and adds a number of new features, so I also recommend familiarising yourself with the [pandoc readme](http://johnmacfarlane.net/pandoc/README.html).

The sections below show you what I think are the most important features of pandoc's Markdown dialect. You should be able to learn the basics in under 15 minutes.

### Sections

Headings are identified by `#`:

    # Heading 1
    ## Heading 2
    ### Heading 3

Create a horizontal rule with three or more hyphens (or asterisks):

    --------
    ********

### Lists

Basic unordered lists use `*`:

    * Bulleted list
    * Item 2
        * Nested bullets need a 4-space indent.
        * Item 2b

If you want multiparagh lists, the second and subsequent paragphs need more indenting:

      * It's possible to put multiple paragraphs of text in a list item. 
    
        But to do that, the second and subsequent paragraphs must be
        indented by four or more spaces. That looks better if the first
        bullet is also indented.

Ordered lists use: `1.`:
    
    1. Item 1
    1. Item 2
    1. Items are umbered automatically, even though they all start with 1.

You can intermingle ordered and bulleted lists, as long as you adhere to the four space rule:

    1.  Item 1.
        *  Item a
        *  Item b
    2.  Item 2.

Definition lists use ` : `

    Definition
      : a statement of the exact meaning of a word, especially in a dictionary.
    List 
      : a number of connected items or names written or printed consecutively, 
        typically one below the other. 
      : barriers enclosing an area for a jousting tournament.

### Inline formatting

Inline format is similarly simple:

    _italic_ or *italic*
    __bold__ or **bold**    
    [link text](destination)
    <http://this-is-a-raw-url.com>

### Tables

There are [four types of table](http://johnmacfarlane.net/pandoc/README.html#tables). I recommend using the pipe table which looks like this:

    | Right | Left | Default | Center |
    |------:|:-----|---------|:------:|
    |   12  |  12  |    12   |    12  |
    |  123  |  123 |   123   |   123  |
    |    1  |    1 |     1   |     1  |

Notice the use of the `:` in the spacer under the heading. This determines the alignment of the column. 
If the data underlying your table exists in R, don't lay it out by hand. Instead use `knitr::kable()` or look at [printr](https://github.com/yihui/printr) or [pander](http://rapporter.github.io/pander/).

### Code

For inline code use `` `code` ``:

    For code inline use `code`.

For bigger blocks of code, use ```` ``` ````. These are known as "fenced" code blocks:

    ```
    # A comment
    add <- function(a, b) a + b
    ```

To add syntax highlighting to the code, put the language name after the backtick:

    ```c
    int add(int a, int b) {
      return a + b;
    }
    ```

(At time of printing, languages supported by pandoc were: actionscript, ada, apache, asn1, asp, awk, bash, bibtex, boo, c, changelog, clojure, cmake, coffee, coldfusion, commonlisp, cpp, cs, css, curry, d, diff, djangotemplate, doxygen, doxygenlua, dtd, eiffel, email, erlang, fortran, fsharp, gnuassembler, go, haskell, haxe, html, ini, java, javadoc, javascript, json, jsp, julia, latex, lex, literatecurry, literatehaskell, lua, makefile, mandoc, matlab, maxima, metafont, mips, modula2, modula3, monobasic, nasm, noweb, objectivec, objectivecpp, ocaml, octave, pascal, perl, php, pike, postscript, prolog, python, r, relaxngcompact, rhtml, ruby, rust, scala, scheme, sci, sed, sgml, sql, sqlmysql, sqlpostgresql, tcl, texinfo, verilog, vhdl, xml, xorg, xslt, xul, yacc, yaml. Syntax highlighting is done by the haskell package [highlighting-kate](http://johnmacfarlane.net/highlighting-kate); see the website for current list.)

When you include R code in your vignette, you usually won't use ```` ```r ````. Instead, you'll use ```` ```{r} ````, which is specially processed by knitr, as described next.

## Knitr

Knitr allows you to intermingle code, results and text. A knitr block looks similar to a fenced code block, but instead of using `r`, you using `{r}`.

    ```{r}
    # Add two numbers together
    add <- function(a, b) a + b
    add(10, 20)
    ```

Knitr will take that code, and run it. As it runs, it captures the output, then later replays it formatted as markdown. It captures printed output, messsages, warnings, errors (optionally) and plots (basic graphics, lattice & ggplot and more). This example is simple, and will generate the following markdown:

    ```r
    # Add two numbers together
    add <- function(a, b) a + b
    add(10, 20)
    ## [1] 30
    ```

Which will be rendered as:

```r
# Add two numbers together
add <- function(a, b) a + b
add(10, 20)
## 30
```

Once you start using knitr in this way, you'll never look back. You can rest easy knowing that all your code works (because it's always run when you build the vignette) and there's no way for input and output to be out of sync.

### Options

You can specify additional options to control the details of the rendering: ```` ```{r, opt1 = val1, opt2 = val2} ````. The most important are listed below:

* `eval = FALSE`. Don't evaluate the code. This is useful if you want
  to show some code that would take a long time to run. Be careful when you
  use this - since the code is no longer run, it's easy to introduce bugs.
  (Your users will be puzzled when they copy & paste code and it doesn't
  work.)

* `echo = FALSE`. Turns of the printing of the code _input_. The output
  will still be printed. Generally, you shouldn't use this in vignettes
  because understand what the code is doing is important (it's more useful
  when writing reports since the code is typically less important than the
  output).

* `results = "hide"`. Don't print code _output_.

* `warning = FALSE`, `message = FALSE`. Suppress display of warnings
  or messages.

* `error = TRUE`: use this if you want knitr to capture any errors in 
  the block and show them inline. This is useful if you want to demonstrate 
  what happens if code throws an error. Whenever you use `error = TRUE`,
  you also need to use `purl = FALSE`: this prevents the code from being 
  included in the summary R document and is important because that file
  must be able to be sourced without error.

* `collapse = TRUE`, `comment = "#>"`: use my preferred way of displaying
  code output.  I usually set these globally by putting the following knitr
  block at the start of my document.

        ```{r, echo = FALSE}
        knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
        ```

*   `results = "asis"`. Treat the output of your R code as literal markdown.
    This is useful if you want to generate text from your R code. For example,
    if you want to generate a table using the pander package, you'd do:
  
        ```{r, results = "asis"}
        pander::pandoc.table(iris[1:3, 1:4])
        ```
    
    That generates a markdown table that looks like:
    
        --------------------------------------------------------
         Sepal.Length   Sepal.Width   Petal.Length   Petal.Width 
        -------------- ------------- -------------- -------------
             5.1            3.5           1.4            0.2     
        
             4.9             3            1.4            0.2     
        
             4.7            3.2           1.3            0.2     
        ---------------------------------------------------------
        
    Which makes a table that looks like:
    
    --------------------------------------------------------
     Sepal.Length   Sepal.Width   Petal.Length   Petal.Width 
    -------------- ------------- -------------- -------------
         5.1            3.5           1.4            0.2     
    
         4.9             3            1.4            0.2     
    
         4.7            3.2           1.3            0.2     
    ---------------------------------------------------------

* `fig.show = "hold"`: hold all figures until the end of the code block.

* `fig.width = 5`, `fig.height = 5`: set the height and width of figures
  (in inches).

The many other options are described at <http://yihui.name/knitr/options>. 

## Development cycle {#vignette-workflow-2}

Run code a chunk at a time using Cmd + Alt + C. Re-run the entire document in a fresh R session using Knit (Cmd + Shift + K). 

You can build all vignettes from the console with `devtools::build_vignettes()`, but this is rarely useful. Instead us `devtools::build()` to create a package bundle with the vignettes included.  RStudio's "Build & reload" does not build vignettes to save time. Similarly, `devtools:install_github()` (and friends) will not build vignettes by default because they're time consuming and may requre additional packages. You can force building with `devtools:install_github(build_vignettes = TRUE)`. This will also install all suggested packages.

## Advice for writing vignettes {#vignette-advice}

> If you're thinking without writing, you only think you're thinking.
> --- Leslie Lamport

When writing a vignette, you're teaching someone how to use your package. You need put yourself in the readers shoes, and adopt the "beginners mind". This is hard to do - it's hard to forget all of the knowledge that you've internalised. I find teaching in-person a really useful way to get feedback on the approach of my vignettes. In person, you get feedback straight away and it's much easier to learn what people already know.

A useful side effect of this approach is that it will help you improve your code. It forces you to re-see the initial onboarding process and to appreciate the parts that are hard. Every time that I've written that describes the initial experience, I've realised that I've missed some important functions. Adding those functions not only helps my users, but it often also helps me! (This is one of the reasons that I like writing books too).

* I strongly recommend literally anything written by Kathy Sierra. Her old blog,
  [Creating passionate users](http://headrush.typepad.com/) is full of advice
  about programming, teaching, and creating valuable tools. I thoroughly
  recommend reading through all the older content. Her new blog,
  [Serious Pony](http://seriouspony.com/blog/), doesn't have as much content,
  but it has some great articles.

* If you'd like to learn how to write better, I highly recommend 
  [Style: Lessons in Clarity and Grace](http://amzn.com/0321898680) by
  Joseph M. Williams and Joseph Bizup. It helps you understand the structure of
  writing so that not only can you more easily recognise bad writing, but 
  you know how to make it better.

Writing a vignette can also make a nice break from coding. In my experience, writing uses a different part of the brain from programming, so if you're sick of programming, trying writing for a bit. (This is related to the idea of [structured programming](http://www.structuredprocrastination.com/).). 

### Organisation

For simpler packages, often one vignette is sufficient. But for more complicated packages you may need more than one. You can have as many vignettes as you like. I tend to think of them like chapters of a book - they should be self-contained, but can link together into a cohesive whole. 

You can link between various vignettes, although it's a slight hack because it takes advantage of the exactly how files are stored on disk. If you want to link to a vignette `abc.Rmd`, just make a link to `abc.html`.

## CRAN notes

Note that you do vignette building locally, so that CRAN receives the html/pdf and the source code. CRAN checks that the code is runnable (by running it), but does not re-build the vignette. This means that any packages used by the vignette must be declared in the `DESCRIPTION`. This means that you can use Rmarkdown (which uses pandoc) even though CRAN doesn't have pandoc installed.

Common problems:

*   The vignette builds interactively, but when checking, fails with an error 
    about a missing package that you know is installed. This means that you've
    forgotten to declare that dependency in the `DESCRIPTION` (usually it should
    go in suggests).

*   Everything works interactively, but the vignette doesn't show up after you've
    installed the package. First, remember that RStudio's "build and reload" 
    doesn't build vignettes, so instead run `devtools::install()`. Next check:
  
    1. The directory is called `vignettes/` and not `vignette/`.

    1. Check that you haven't inadvertently excluded the vignettes with
       `.Rbuildignore`
       
    1. Ensure you have the necessary vignette metadata.

*   If you use `error = TRUE`, you must use `purl = FALSE`.

You'll need to watch the file size. If you include a lot of graphics, it's easy to create a very large file. There are no hard and fast rules, but if you have a very large vignette be prepared to either justify the file size, or to make it smaller.

## Where next

If you write a nice vignette, you might want to consider submitting it to the Journal of Statistical Software or the R Journal. Both are electronic only journals and peer-reviewing can be very helpful for improving the quality of your vignette and the related software.

