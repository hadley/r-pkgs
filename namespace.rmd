---
title: Namespaces
layout: default
output: bookdown::html_chapter
---

# Namespace {#namespace}

The package `NAMESPACE` is one of the more confusing parts of building a package. It's a fairly advanced topic, and by-and-large, not that important if you are only developing packages for yourself. However, understanding namespaces is vital if you plan to submit your package to CRAN because they ensure that your package plays well with others.

## Motivation

As the name suggests, namespaces provide "spaces" for "names". They provide a context for looking up the value of an object associated with a name. 

Namespaces solve two problems:

  * What do you do if you've loaded two packages that have a function
    with same name? Namespaces provide an extension to the standard way of 
    looking up the value of an object: instead of just typing `objectname`, 
    you can type `package::objectname`.  
   
    For example, both plyr and Hmisc provide a `summarize()` function. If 
    you load plyr, then Hmisc, `summarize()` will refer to the HMisc 
    version; if you load the packages in the opposite order, then 
    `summarize()` will refer to the plyr version. This is obviously 
    confusing, so instead, you can be explicit and refer to 
    `Hmisc::summarise()` or `plyr::summarise()`. Then it doesn't matter the
    order in which the packages were loaded.

  * What happens if someone changes the definition of a function that you
    rely on? For example, take the simple `nrow()` function in base R:
  
    ```{r}
    nrow
    ```
    
    It's defined in terms of `dim()`, sohat happens if we override `dim()` 
    with our own definition? Does `nrow()` break?
    
    ```{r}
    dim <- function(x) c(1, 1)
    dim(mtcars)
    nrow(mtcars)
    ```

    Suprisingly, it does not! That's because when `nrow()` looks for an object 
    called `dim()`, it uses the the package namespace, so it finds `dim()` in 
    the base environment, not the `dim()` we created in the global environment.

There are two sides to the name space:

* The __imports__, which defines how a function in a package finds a function
  in anotherp ackage. 
  
* The __exports__, which split functions in packages into two groups: interal 
  and external (or exported). Internal functions are available only within your 
  package - they can't (easily) be used from another package. You export a 
  minimal set of functions to be used by others; the fewer functions you export, 
  the smaller the chance of a conflict with another package. (Conflicts aren't 
  the end of the world, but they're best avoided where possible because it
  makes the lives of your users easier.)

The two sides of the package namespace are both described by the `NAMESPACE`. You'll learn what this file looks like in the next section, and then you'll learn more details about exporting and importing functions (and other objects).

## The `NAMESPACE`

The following code is an exercept of the `NAMSPACE` file from the testthat package.

    # Generated by roxygen2 (4.0.2): do not edit by hand
    S3method(as.character,expectation)
    S3method(compare,character)
    export(auto_test)
    export(auto_test_package)
    export(colourise)
    export(context)
    exportClasses(ListReporter)
    exportClasses(MinimalReporter)
    importFrom(methods,setRefClass)
    useDynLib(testthat,duplicate_)
    useDynLib(testthat,reassign_function)

You can see that the `NAMESPACE` file looks a bit like R code. Each line contains a __directive__: `S3method()`, `export()`, `exportClasses()`, and so on. Each directive describes an R object, and says whether it's exported from this package to be used by others, or it's imported from another package to be used locally. 

In total, there are ten namespace directives. Five describe exports: 

* `export()`: export functions (including S3 and S4 generics).
* `exportPattern()`: export all functions that match a pattern.
* `exportClasses()`, `exportMethods()`: export S4 classes and methods.
* `S3method()`: export S3 methods.

And five describe imports:

* `import()`: import all functions from a package.
* `importFrom()`: import selected functions from a package.
* `importClassesFrom()`, `importMethodsFrom()`: import S4 classes and methods 
   from a package.
* `useDynLib()`: import a function from C. This is described in more
   detail in [compiled code](#src).

I don't recommend writing these directives by hand. Instead, in this chapter you'll learn how to generate the `NAMESPACE` file with roxygen2. There are three main advantages to using roxygen2:

* Namespace definitions live next to functions, so when you read the code
  it's easy to see what's exported.

* Roxygen2 abstracts away some of the details of the `NAMESPACE`. For example,
  you only need to learn `@export` which will automatically generate the 
  right directive for functions, S3 methods, S4 methods and S4 classes.

* Roxygen2 makes a tidy `NAMESPACE` for you - it only unique directives (so you 
  can repeat them as needed), and it sorts them alphabetically. This is 
  particularly important if you're using git, as it minimises inconsequential
  differences.

## Search path

* Imports vs. depends

## Workflow

Generating the namespace with roxygen2 is just like roxygen2 for function documentation. You use roxygen2 blocks (starting with `#'`) and tags (starting with `@`). The workflow is also similar:

1. Add roxygen comments to your `.R` files.

1. Run `devtools::document()` (or press Cmd + Shift + D in RStudio) to 
   convert roxygen comments to `.Rd` files.

1. Look at `NAMESPACE` and run tests.

1. Rinse and repeat until the correct functions are exported.

## Exports

For a function to be usable outside of your package, you must __export__ it. When you create a new package with `devtools::create()`, it produces a temporary `NAMESPACE` that exports everything in your package that doesn't start with `.`. If you're just working locally, it's fine to export everything in your package. However, if you're planning on sharing your packae with others, it's a really good idea to only export the needed functions. This reduces the chances of a conflict with another package.

To export an object, put `@export` in its roxygen block. For example:

```{r}
#' @export
foo <- function(x, y, z) {
  ...
}
```

This will then generate `export()`, `exportMethods()`, `exportClass()` or `S3method()` depending on the type of the object.
 
You export functions that you want to make available. Exported functions must be documented, and you must be cautious when changing their interface. All functions used in examples must be exported.

Package data doesn't use the namespace mechanism and should never be exported. 

The following sections describes what you should export if you're using S3, S4 or RC.

### S3 

If you want others to be able to create instances of an S3 class, `@export` the constructor function. S3 generics are just regular R functions, you can `@export` them like functions. 

S3 methods are the most complicated because there are four basic scenarios:

* A method for an exported generic: export every method.

* A method for an internal generic: technically, you don't need to export
  these methods. However, I recommend exporting every S3 method you write
  because it's a simpler and makes it less likely that you introduce hard to 
  find bugs. You can use `devtools::missing_s3()` to list all S3 methods that 
  you've forgotten to export.

* A method for a generic in a required package. You'll need to import the
  generic (see below), and export the method.

* A method for a generic in a suggested package. Namespace directives must
  refer to available functions, so can not reference suggested packages. 
  It's possible to use package hooks and code to add this at run-time,
  but this is sufficiently complicated that I don't currently recommend it.
  Instead, you'll have to architect your package dependencies to avoid this
  scenario.

### S4

S4 classes: if you want others to be able to extend your class, `@export` it.
If you want others to create instances of your class, but not extend it,
`@export` the constructor function, but not the class.

```{r, eval = FALSE}
# Can extend and create
#' @export
setClass("A")

# Can extend, but constructor not exported
#' @export
B <- setClass("B")

# Can create, but not extend
#' @export C
C <- setClass("C")

# Can create and extend
#' @export D
#' @exportClass D
D <- setClass("D")
```

S4 generics: `@export` if you want the generic to be publicly usable.

S4 methods: you only need to `@export` methods for generics that you did not define. But `@export`ing every method is a good idea as it will not cause problems and prevents you from forgetting to export an important method.

### RC

The same principles apply as for S4 classes. Note that due to the way that RC is currently implemented, it's typically impossible for your classes to be extended outside of your package.

## Imports {#imports}

The `NAMESPACE` also controls which external functions can be used by your package without qualification through import directives. It's important to distinguish between import directives in the `NAMESPACE` and the `Import` field in the `DESCRIPTION`:

* `DESCRIPTION`: package level; controls which packages are 
  installed when your package is installed. You must add this manually - 
  Roxygen2 does not modify this field.
  
* `NAMESPACE`: object level; controls which functions and classes are 
  available inside your package without using `::`. This file is edited by
  Roxygen2.
  
It is common for packages to be listed in the `DESCRIPTION`, but not in the `NAMESPACE`. In fact, this is the default I recommend: list the package in `DESCRIPTION` so that it's installed, then always refer to it explicitly with `pkg::fun()`. Unless there are a strong factors otherwise, it's better to default to this explicit form which is a little more work to write, but much easier to read.

Every package mentioned in `NAMESPACE` must also be present the the `Imports` field (or the `Depends` field, as described below).

To make C/C++ functions available R, see [compiled code](#src).

### Functions

If you are using just a few functions from another package, the recommended option is to note the package name in the `Imports:` field of the `DESCRIPTION` file and call the function(s) explicitly using `::`, e.g., `pkg::fun()`.

If you are using functions repeatedly, you can avoid the `::` by importing the function with  `@importFrom pgk fun`. This also has a small performance benefit, because `::` adds approximately 5 Âµs to function evaluation time.

Alternatively, if you are using repeatedly using many functions from another package, you can import them in one command with `@import package`. This is the least recommended solution: it makes your code harder to read (because you can't tell where a function is coming from), and if you `@import` many packages, the chance of a conflicting function name increases.

### S3

S3 generics are just functions, so the same rules for functions apply.  S3 methods always travel along with the generic, so as long as you can access the generic (either implicitly or explicitly), the methods will also be loaded.

### S4 {#namespace-s4}

To use classes defined in another package: `@importClassesFrom package ClassA ClassB ...`. Place this next to the class that inherit from the imported classes, or the methods that implement a generic for the imported classes.

To use generics defined in another package: `@importMethodsFrom package GenericA GenericB ...`. Place these next to the methods that use the imported generics.

Since S4 is implemented in the methods package, you also need to make sure that's available. There is some slightly trickiness here because while the method package is always avaialble on the search path when you're working interactively in R, it is not automatically loaded by `Rscript`, a tool for running R from the command line.

  * Pre R 3.2.0: `Depends: methods` in `DESCRIPTION`.  \
    Post R 3.2.0: `Imports: methods` in `DESCRIPTION`.
  
  * Since you'll being using a lot of functions from `methods`, 
    you'll probably also want to import the complete package with:
    
    ```{r}
    #' @imports methods
    NULL
    ```
    
    Or you might just wanted import the most commonly used functions:
    
    ```{r}
    #' @importFrom methods setClass setGeneric setMethod setRefClass
    NULL
    ```
  
    It doesn't matter where these import definitions go, but if you have
    package level docs, that's a natural place to put them.
