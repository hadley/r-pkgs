---
title: Namespaces
layout: default
output: bookdown::html_chapter
---

# Namespace {#namespace}

The package `NAMESPACE` is one of the more confusing parts of building a package. It's a fairly advanced topic, and by-and-large, not that important if you are only developing packages for yourself. However, understanding namespaces is vital if you plan to submit your package to CRAN because they ensure that your package plays well with others.

As the name suggests, namespaces provide "spaces" for "names", providing a context for evaluating which object is found when you look for it. Namespaces solve two problems:

  * A developer, they ensure that your functions always call the functions you
    expect, regardless of what other packages the user has loaded. For example, 
    take the simple `nrow()` function:
  
    ```{r}
    nrow
    ```
    
    It's defined in terms of `dim()`, so what happens if we override `dim()` 
    with our own definition --- does `nrow()` break?
    
    ```{r}
    dim <- function(x) c(1, 1)
    dim(mtcars)
    nrow(mtcars)
    ```

    Suprisingly, it does not! That's because when `nrow()` looks for an object 
    called `dim()`, it uses the namespace, looking up `dim()` in the base 
    environment, not our `dim()` in the global environment.

  * As a user, when multiple packages provide functions with the same name, they 
    allow you to be explicit about which to you use. Namespaces provide an 
    extension to the standard way of looking up the value of an object: instead 
    of just typing `objectname`, you type `package::objectname`.  
   
    For example, both `plyr` and `Hmisc` provide a `summarise()` function. If 
    you load `plyr`, then `Hmisc`, `summarise` will refer to the HMisc 
    implementation; if you load the packages in the opposite order, then 
    `summarise` will refer to the plyr implementation. This is obviously 
    confusing, so instead, you can be explicit and refer to either 
    `Hmisc::summarise` or `plyr::summarise` - then it doesn't matter in which 
    order the packages are loaded.

Namespaces also reduce the chance of conflicting function names between packages because they split functions into internal and external (or exported). Internal functions are available only within your package - they can't (easily) be used from another package. That means you can name them whatever you want without worry. Then you only export a minimal set of functions to define the external interface to your package; the fewer functions you export, the smaller the chance of a conflict with another package. (Conflicts aren't the end of the world, but they're best avoided where possible because it makes the lives of your users easier.)

## The `NAMESPACE`

The following block shows an exercept of the `NAMSPACE` file from the testthat package.

    # Generated by roxygen2 (4.0.2): do not edit by hand
    S3method(as.character,expectation)
    S3method(compare,character)
    export(auto_test)
    export(auto_test_package)
    export(colourise)
    export(context)
    exportClasses(ListReporter)
    exportClasses(MinimalReporter)
    importFrom(methods,setRefClass)
    useDynLib(testthat,duplicate_)
    useDynLib(testthat,reassign_function)

You can see that the `NAMESPACE` file looks a bit like R code. Each line contains a __directive__: `S3method()`, `export()`, `exportClasses()`, and so on. Each directive describes an R object, and says whether it's exported from this package to be used by others, or it's imported from another package to be used locally. 

In total, there are ten namespace directives. Five describe exports: 

* `export()`: export functions (including S3 and S4 generics).
* `exportPattern()`: export all functions that match a pattern
* `exportClasses()`, `exportMethods()`: export S4 classes and methods.
* `S3method()`: export S3 methods.

And five describe imports:

* `import()`: import all functions from a package.
* `importFrom()`: import selected functions from a package.
* `importClassesFrom()`, `importMethodsFrom()`: import S4 classes and methods 
   from a package.
* `useDynLib()`: import a function from C. This is described in more
   detail in [compiled code](#src).

I don't recommend writing these directives by hand. Instead, generate the `NAMESPACE` file (which defines the namespace), with roxygen2. There are three main advantages to using roxygen2:

* Namespace definitions live next to functions, so when you read the code
  it's easy to see what's exported.

* Roxygen2 abstracts away some of the details of the `NAMESPACE`. For example,
  you only need to learn `@export` which will automatically generate the 
  right directive for functions, S3 methods, S4 methods and S4 classes.

* Roxygen2 makes a tidy `NAMESPACE` for you - it only unique directives (so you 
  can repeat them as needed), and it sorts them alphabetically.

## Search path

* Imports vs. depends

## Workflow

Generating the namespace with roxygen2 is just like roxygen2 for function documentation. You use roxygen2 blocks (starting with `#'`) and tags (starting with `@`). The workflow is also similar:

1. Add roxygen comments to your `.R` files.

1. Run `devtools::document()` (or press Cmd + Shift + D in RStudio) to 
   convert roxygen comments to `.Rd` files.

1. Look at `NAMESPACE` and run tests.

1. Rinse and repeat until the correct functions are exported.

## Exports

For a function to be usable outside of your package, you must __export__ it. When you create a new package with `devtools::create()`, it produces a temporary `NAMESPACE` that exports everything in your package that doesn't start with `.`. If you're just working locally, it's fine to export everything in your package. However, if you're planning on sharing your packae with others, it's a really good idea to only export the needed functions. This reduces the chances of a conflict with another package.

To export an object, put `@export` in its roxygen block. For example:

```{r}
#' @export
foo <- function(x, y, z) {
  ...
}
```

This will then generate `export()`, `exportMethods()`, `exportClass()` or `S3method()` depending on the type of the object.
 
You export functions that you want to make available. Exported functions must be documented, and you must be cautious when changing their interface. All functions used in examples must be exported.

Package data doesn't use the namespace mechanism and should never be exported. 

The following sections describes what you should export if you're using S3, S4 or RC.

### S3 

If you want others to be able to create instances of an S3 class, `@export` the constructor function. S3 generics are just regular R functions, you can `@export` them like functions. 

S3 methods are the most complicated because there are four basic scenarios:

* A method for an exported generic: export every method.

* A method for an internal generic: technically, you don't need to export
  these methods. However, I recommend exporting every S3 method you write
  because it's a simpler and makes it less likely that you introduce hard to 
  find bugs. You can use `devtools::missing_s3()` to list all S3 methods that 
  you've forgotten to export.

* A method for a generic in a required package. You'll need to import the
  generic (see below), and export the method.

* A method for a generic in a suggested package. Namespace directives must
  refer to available functions, so can not reference suggested packages. 
  It's possible to use package hooks and code to add this at run-time,
  but this is sufficiently complicated that I don't currently recommend it.
  Instead, you'll have to architect your package dependencies to avoid this
  scenario.

### S4

S4 classes: if you want others to be able to extend your class, `@export` it.
If you want others to create instances of your class, but not extend it,
`@export` the constructor function, but not the class.

```{r, eval = FALSE}
# Can extend and create
#' @export
setClass("A")

# Can extend, but constructor not exported
#' @export
B <- setClass("B")

# Can create, but not extend
#' @export C
C <- setClass("C")

# Can create and extend
#' @export D
#' @exportClass D
D <- setClass("D")
```

S4 generics: `@export` if you want the generic to be publicly usable.

S4 methods: you only need to `@export` methods for generics that you did not define. But `@export`ing every method is a good idea as it will not cause problems and prevents you from forgetting to export an important method.

### RC

The same principles apply as for S4 classes. Note that due to the way that RC is currently implemented, it's typically impossible for your classes to be extended outside of your package.

## Imports {#imports}

The `NAMESPACE` also controls which external functions can be used by your package without qualification through import directives. It's important to distinguish between import directives in the `NAMESPACE` and the `Import` field in the `DESCRIPTION`:

* `DESCRIPTION`: package level; controls which packages are 
  installed when your package is installed. You must add this manually - 
  Roxygen2 does not modify this field.
  
* `NAMESPACE`: object level; controls which functions and classes are 
  available inside your package without using `::`. This file is edited by
  Roxygen2.
  
It is common for packages to be listed in the `DESCRIPTION`, but not in the `NAMESPACE`. In fact, this is the default I recommend: list the package in `DESCRIPTION` so that it's installed, then always refer to it explicitly with `pkg::fun()`. Unless there are a strong factors otherwise, it's better to default to this explicit form which is a little more work to write, but much easier to read.

Every package mentioned in `NAMESPACE` must also be present the the `Imports` field (or the `Depends` field, as described below).

To make C/C++ functions available R, see [compiled code](#src).

### Functions

If you are using just a few functions from another package, the recommended option is to note the package name in the `Imports:` field of the `DESCRIPTION` file and call the function(s) explicitly using `::`, e.g., `pkg::fun()`.

If you are using functions repeatedly, you can avoid the `::` by importing the function with  `@importFrom pgk fun`. This also has a small performance benefit, because `::` adds approximately 5 Âµs to function evaluation time.

Alternatively, if you are using repeatedly using many functions from another package, you can import them in one command with `@import package`. This is the least recommended solution: it makes your code harder to read (because you can't tell where a function is coming from), and if you `@import` many packages, the chance of a conflicting function name increases.

### S3

S3 generics are just functions, so the same rules for functions apply.  S3 methods always travel along with the generic, so as long as you can access the generic (either implicitly or explicitly), the methods will also be loaded.

### S4 {#namespace-s4}

To use classes defined in another package: `@importClassesFrom package ClassA ClassB ...`. Place this next to the class that inherit from the imported classes, or the methods that implement a generic for the imported classes.

To use generics defined in another package: `@importMethodsFrom package GenericA GenericB ...`. Place these next to the methods that use the imported generics.

Since S4 is implemented in the methods package, you also need to make sure that's available. There is some slightly trickiness here because while the method package is always avaialble on the search path when you're working interactively in R, it is not automatically loaded by `Rscript`, a tool for running R from the command line.

  * Pre R 3.2.0: `Depends: methods` in `DESCRIPTION`.  \
    Post R 3.2.0: `Imports: methods` in `DESCRIPTION`.
  
  * Since you'll being using a lot of functions from `methods`, 
    you'll probably also want to import the complete package with:
    
    ```{r}
    #' @imports methods
    NULL
    ```
    
    Or you might just wanted import the most commonly used functions:
    
    ```{r}
    #' @importFrom methods setClass setGeneric setMethod setRefClass
    NULL
    ```
  
    It doesn't matter where these import definitions go, but if you have
    package level docs, that's a natural place to put them.
